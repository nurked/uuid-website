<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
</head>



<body>
    <style>
        body {
            padding: 0px;
            margin: 0px;
        }

        header {
            color: white;
            font-family: 'Comfortaa', cursive;
            background-color: rgb(17, 17, 108);
            /* background: linear-gradient(0deg, rgba(255,255,255,1) 48%, rgb(17, 17, 108) 50%); */
            /* background-image: linear-gradient(0deg,white, rgb(17, 17, 108)); */
            min-height: 15vh;
        }

        footer {
            background-color: #e6e6e6;
        }

        .bitcode {
            font-weight: bold;
            font-size: 1.5rem;
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 2fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 2fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 2fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr; 
            grid-template-rows: 1fr 1fr 1fr 1fr; 
            gap: 0px 0px; 
            
        }

        .bg {
            background-color: #002b36;
            
        }

        .explain {
            padding: 1px 8px 2px 8px;
            border-radius: 6px;
        }

        .box {
            max-width: 600px;
        }

        .current-text {
            height: 15vh;
            display: flex;
            justify-content: center;
            align-items: flex-end;
        }

        .uuid-text {
            color: #fdf6e3;
        }

        .timestamp {
            color:#859900;
        }

        .version {
            color:#dc322f;
        }
        .variant {
            color:#d33682;
        }

        .random {
            color: #fdf6e3;
        }

        .precision {
            color: #b58900;
        }

        .node {
            color: #268bd2;
        }

        .bits {
            cursor: pointer;
            font-weight: bold;
        }

        .counter {
            color: #2aa198;
        }

        .hex {
            cursor: pointer;
        }

        

    </style>
    <div class="content">
        <header>
            <div class="current-text">
                <h1 class="display-3">Hello, UUIDv7!</h1>
            </div>
        </header>
        <main>
            <div class="container">
                <div class="row justify-content-center pt-2">
                    
                    <div class="col col-8">
                    <p>
                    A common case for modern applications is to create a unique
                    identifier for use as a primary key in a database table.  This
                    identifier usually implements an embedded timestamp that is sortable
                    using the monotonic creation time in the most significant bits.  In
                    addition the identifier is highly collision resistant, difficult to
                    guess, and provides minimal security attack surfaces.  None of the
                    existing UUID versions, including UUIDv1, fulfill each of these
                    requirements in the most efficient possible way.
                    </p>

                    <p>
                    Instead we are introducing UUIDv7. Take a look, we have a freshly generated UUIDv7 right here:
                    </p>
                    
                    </div>
                </div>
                <div class="row fs-4">
                    
                </div>
            </div>
            <div class="container-fluid bg">
            
                <div vg-if="len(c.bits) > 0" class="row justify-content-center font-monospace">
                    <div class="box p-2">
                        <div class="col text-center" style="color:#fdf6e3">
                            <span vg-content="c.uuid" class="uuid-text display-4"></span>
                        </div>
                        <div class="bitcode">
                            <div vg-for="c.bits" vg-key="key"> 
                                <span :class="c.getClass(key)" vg-content="c.display(value)"></span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="row justify-content-end">
                    <div class="col col-3 d-flex justify-content-center p-2">
                        <button class="btn btn-primary" @click="c.GetNewUUID(event)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-clockwise" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                                <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                            </svg> 
                            Get new UUID
                        </button>
                    </div>
                </div>


            </div>
            <div class="container">
                <div class="row justify-content-center">
                    <div class="col col-8 pt-4">
                        <p><span class="timestamp explain bg">Unix timestamp</span> &ndash; no more flying DeLorians. You always in control and you know where and when this UUID happened. First 36 bits are dedicated for the Unix timestamp. No random bit ordering. No little-endian bits. It is just a number that can be parsed by any computer system. </p>
                        <p><span class="precision explain bg">Sub-second precision bits</span> &ndash; Need to be more specific about your time? UUIDv7 allows you to store up to 48 bits of sub-second precision. Not just that. The data is encoded with a trickle of magic that allows it to be binary sortable. But we are a very good magicians. We explain all our tricks.</p>
                        <p><span class="counter explain bg">Counter</span> &ndash; Is your flux capacitor overcharged and you are producing millions of UUIDs per milli-second? Use counter to keep them well ordered. </p>
                        <p><span class="node explain bg">Node data</span> &ndash; You can store an information about a machine that produced this UUID in this block.</p>
                        <p><span class="random explain bg">Random data</span> &ndash; Add some randomity at the end to ensure that your UUID is totally unique and no other UUIDs are just like it. </p>
                        <p><span class="version explain bg">Version</span> &ndash; There are times to be boring for a reason of a backward-compatibility. This field contains the version number to be compatible with UUIDv4. </p>
                        <p><span class="variant explain bg">Variant</span> &ndash; Even more boring stuff for compatibility with UUIDv4. </p>
                    </div>
                </div>
                <div class="row justify-content-center">
                    <div class="col col-8">
                        <p>
                            Special mention to our amazing counter precision encoding algorithm.
                        </p>
                    </div>
                </div>

            </div>

        </main>

        <footer class="footer">
            <div class="container">
                <div class="row pt-5 justify-content-center">
                    <div class="col col-8">
                        <p><a href="https://datatracker.ietf.org/doc/draft-peabody-dispatch-new-uuid-format/">IETF: New UUID formats</a></p>
                        <p><a href="https://github.com/uuid6/uuid6-ietf-draft">Github: uuid6-ietf-draft</a></p>
                        <p><a href="https://github.com/uuid6/uuid6go-proto">golang generator uuid6go-proto</a></p>
                        <p><a href="https://vugu.org">site written in vugu</a></p>
                        <p>Contact: <a href="mailto:brad@peabody.io">Brad G. Peabody</a> and <a href="mailto:kydavis@cisco.com">Kyzer R. Davis</a></p>
                        <p class="text-end">Copyright &copy; 2021</p>
                    </div>
                </div>
            </div>    
        </footer>
    </div>
</body>

<script type="application/x-go">
 import (
//     "encoding/json"
//     "net/http"
	uuid "github.com/uuid6/uuid6go-proto"
    "log"

)


type Root struct {
    selected string `vugu:"data"`
    counterPrecisionBits int `vugu:"data"`
    nodePrecisionBits int `vugu:"data"`
    node uint64 `vugu:"data"`
    subsecondPrecisionLength int `vugu:"data"`
    bits []bool `vugu:"data"`
    uuid string `vugu:"data"`
}


func (c *Root) Init(ctx vugu.InitCtx) {
        var gen uuid.UUIDv7Generator
        c.counterPrecisionBits = 8
        c.nodePrecisionBits = 4
        c.node = 7
        c.subsecondPrecisionLength = 16
		gen.CounterPrecisionBits = c.counterPrecisionBits
		gen.NodePrecisionBits = c.nodePrecisionBits
		gen.Node = c.node
		gen.SubsecondPrecisionLength = c.subsecondPrecisionLength

        var uid = gen.Next()
        
        c.bits = uid.ToBitArray();
        c.uuid = uid.ToString();
}


func (c *Root) getClass(key int) string {
    class := ""
    if key < 36 {
        class = "timestamp"
    } else if  key == 48 || key == 49 || key == 50 || key == 51 {
        class = "version"
    } else if  key == 64 || key == 65 {
        class = "variant"
    } else if c.subsecondPrecisionLength !=0 && key < indexer(c.subsecondPrecisionLength+1) {
        class = "precision"
    } else if c.counterPrecisionBits !=0 && key < indexer(c.subsecondPrecisionLength+c.counterPrecisionBits+1) {
        class = "counter"
    } else if c.nodePrecisionBits !=0 && key < indexer(c.subsecondPrecisionLength+c.counterPrecisionBits+c.nodePrecisionBits+1) {
        class = "node"
    } else {
        class = "random"
    }

    return class
}

func (c *Root) display( value bool) string {
    val := "0" 
    if value {
        val = "1"
    }

    return val
}


func (c *Root) GetNewUUID(event vugu.DOMEvent) {
    ee := event.EventEnv()

    go func() {
        var gen uuid.UUIDv7Generator
		gen.CounterPrecisionBits = c.counterPrecisionBits
		gen.NodePrecisionBits = c.nodePrecisionBits
		gen.Node = c.node
		gen.SubsecondPrecisionLength = c.subsecondPrecisionLength

        var uid = gen.Next()
        
        ee.Lock()
        c.bits = uid.ToBitArray();
        c.uuid = uid.ToString();
        defer ee.UnlockRender()
        log.Print(event.PropString("target", "value"))        
        log.Print(uid.ToMicrosoftString())        
    }()
}

// indexer returns updated index of a bit in the array of bits. It skips bits 48-51 and 64,65
// for those containt information about Version and Variant and can't be populated by the
// precision bits. It also omits first 36 bits of timestamp at the beginning of the GUID
func indexer(input int) int {
	out := 35 + input //Skip the TS block and start counting right after ts block
	if input > 11 {   //If we are bumbing into a ver block, skip it
		out += 4
	}

	if input > 23 { //If we are bumping into a var block
		out += 2
	}
	return out
}




</script>