
<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
</head>



<body class="">
    <style>
        body {
            padding: 0px;
            margin: 0px;
        }

        header {
            color: white;
            font-family: 'Comfortaa', cursive;
            background-color: rgb(17, 17, 108);
            /* background: linear-gradient(0deg, rgba(255,255,255,1) 48%, rgb(17, 17, 108) 50%); */
            /* background-image: linear-gradient(0deg,white, rgb(17, 17, 108)); */
            min-height: 20vh;
        }

        .bitcode {
            font-weight: bold;
            font-size: 1.5rem;
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 2fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 2fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 2fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr; 
            grid-template-rows: 1fr 1fr 1fr 1fr; 
            gap: 0px 0px; 
        }

        .current-text {
            height: 20vh;
        }

        .timestamp {
            color:#428042;
        }

        .version {
            color:rgb(255, 48, 48);
        }
        .variant {
            color:#caa898;
        }

        .random {
            color: #8a04af;
        }

        .precision {
            color: #8d7300;
        }

        .node {
            color: #258184;
        }

        .bits {
            cursor: pointer;
            font-weight: bold;
        }

        .counter {
            color: blue
        }

        .hex {
            cursor: pointer;
        }

        

    </style>
    <div class="content">
        <header>
            <div class="current-text text-center align-middle" style="display: flex;justify-content: center;align-items: flex-end;">
                <h1 class="display-1">Hello, UUIDv7!</h1>
            </div>
        </header>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320">
            <path fill="rgb(17, 17, 108)" fill-opacity="1"
                d="M0,128L60,149.3C120,171,240,213,360,218.7C480,224,600,192,720,160C840,128,960,96,1080,74.7C1200,53,1320,43,1380,37.3L1440,32L1440,0L1380,0C1320,0,1200,0,1080,0C960,0,840,0,720,0C600,0,480,0,360,0C240,0,120,0,60,0L0,0Z">
            </path>
        </svg>
        <main>
            <div class="container">
                <div class="row">
                    <div class="col">Let me explain you how it works. Take a look, we have a freshly generated UUIDv7 right here:</div>
                </div>
                <div class="row fs-4">
                    <div class="col text-center display-4 font-monospace">
                        <span vg-content="c.uuid"></span>
                    </div>
                </div>

                <div vg-if="len(c.bits) > 0" class="bitcode  font-monospace">
                    <div vg-for="c.bits" vg-key="key"> 
                        <span :class="c.getClass(key)" vg-content="c.display(value)"></span>
                    </div>

                </div>
                <div class="row justify-content-md-center">
                    <div class="col col-3 d-flex justify-content-center">
                        <button class="btn btn-primary" @click="c.GetNewUUID(event)">Get new UUID</button>
                    </div>
                </div>
                <div class="row">
                    <div class="col">
                        <ul>
                            <li>
                                <span class="timestamp">Unix timestamp</span> &ndash; no more flying DeLorians. You always in control and you know where and when this UUID happened. First 36 bits are dedicated for the Unix timestamp. No random bit ordering. No little-endian bits. It is just a number that can be parsed by any computer system. 
                            </li>
                            <li>
                                <span class="precision">Sub-second precision bits</span> &ndash; Need to be more specific about your time? UUIDv7 allows you to store up to 48 bits of sub-second precision. Not just that. The data is encoded with a trickle of magic that allows it to be binary sortable. But we are a very good magicians. We explain all our tricks.
                            </li>
                            <li>
                                <span class="counter">Counter</span> &ndash; Is your flux capacitor overcharged and you are producing millions of UUIDs per milli-second? Use counter to keep them well ordered. 
                            </li>
                            <li>
                                <span class="node">Node data</span> &ndash; You can store an information about a machine that produced this UUID in this block.
                            </li>
                            <li>
                                <span class="random">Random data</span> &ndash; Add some randomity at the end to ensure that your UUID is totally unique and no other UUIDs are just like it. 
                            </li>
                            <li>
                                <span class="version">Version</span> &ndash; There are times to be boring for a reason of a backward-compatibility. This field contains the version number to be compatible with UUIDv4. 
                            </li>
                            <li>
                                <span class="variant">Variant</span> &ndash; Even more boring stuff for compatibility with UUIDv4. 

                            </li>
                        </ul>
                    </div>
                </div>

            </div>

        </main>

        <footer class="footer">
            (C) 2020
        </footer>
    </div>
</body>

<script type="application/x-go">
 import (
//     "encoding/json"
//     "net/http"
	uuid "github.com/uuid6/uuid6go-proto"
    "log"

)


type Root struct {
    selected string `vugu:"data"`
    counterPrecisionBits int `vugu:"data"`
    nodePrecisionBits int `vugu:"data"`
    node uint64 `vugu:"data"`
    subsecondPrecisionLength int `vugu:"data"`
    bits []bool `vugu:"data"`
    uuid string `vugu:"data"`
}


func (c *Root) Init(ctx vugu.InitCtx) {
        var gen uuid.UUIDv7Generator
        c.counterPrecisionBits = 8
        c.nodePrecisionBits = 4
        c.node = 7
        c.subsecondPrecisionLength = 16
		gen.CounterPrecisionBits = c.counterPrecisionBits
		gen.NodePrecisionBits = c.nodePrecisionBits
		gen.Node = c.node
		gen.SubsecondPrecisionLength = c.subsecondPrecisionLength

        var uid = gen.Next()
        
        c.bits = uid.ToBitArray();
        c.uuid = uid.ToString();
}


func (c *Root) getClass(key int) string {
    class := ""
    if key < 36 {
        class = "timestamp"
    } else if  key == 48 || key == 49 || key == 50 || key == 51 {
        class = "version"
    } else if  key == 64 || key == 65 {
        class = "variant"
    } else if c.subsecondPrecisionLength !=0 && key < indexer(c.subsecondPrecisionLength+1) {
        class = "precision"
    } else if c.counterPrecisionBits !=0 && key < indexer(c.subsecondPrecisionLength+c.counterPrecisionBits+1) {
        class = "counter"
    } else if c.nodePrecisionBits !=0 && key < indexer(c.subsecondPrecisionLength+c.counterPrecisionBits+c.nodePrecisionBits+1) {
        class = "node"
    } else {
        class = "random"
    }

    return class
}

func (c *Root) display( value bool) string {
    val := "0" 
    if value {
        val = "1"
    }

    return val
}


func (c *Root) GetNewUUID(event vugu.DOMEvent) {
    ee := event.EventEnv()

    go func() {
        var gen uuid.UUIDv7Generator
		gen.CounterPrecisionBits = c.counterPrecisionBits
		gen.NodePrecisionBits = c.nodePrecisionBits
		gen.Node = c.node
		gen.SubsecondPrecisionLength = c.subsecondPrecisionLength

        var uid = gen.Next()
        
        ee.Lock()
        c.bits = uid.ToBitArray();
        c.uuid = uid.ToString();
        defer ee.UnlockRender()
        log.Print(event.PropString("target", "value"))        
        log.Print(uid.ToMicrosoftString())        
    }()
}

// indexer returns updated index of a bit in the array of bits. It skips bits 48-51 and 64,65
// for those containt information about Version and Variant and can't be populated by the
// precision bits. It also omits first 36 bits of timestamp at the beginning of the GUID
func indexer(input int) int {
	out := 35 + input //Skip the TS block and start counting right after ts block
	if input > 11 {   //If we are bumbing into a ver block, skip it
		out += 4
	}

	if input > 23 { //If we are bumping into a var block
		out += 2
	}
	return out
}




</script>